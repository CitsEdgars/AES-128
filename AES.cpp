#include "AES.h"
#include <vector>
#include <iostream>
#include <fstream>

const static int encMatrix[4][4] = { {0x02,0x03,0x01,0x01},
							  {0x01,0x02,0x03,0x01},
							  {0x01,0x01,0x02,0x03},
							  {0x03,0x01,0x01,0x02} };
const static int decMatrix[4][4] = { {0x0e,0x0b,0x0d,0x09},
							  {0x09,0x0e,0x0b,0x0d},
							  {0x0d,0x09,0x0e,0x0b},
							  {0x0b,0x0d,0x09,0x0e} };
const static int sbox_enc[256] = { 0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
							,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
							,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
							,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
							,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
							,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
							,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
							,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
							,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
							,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
							,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
							,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
							,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
							,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
							,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
							,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16 };
const static int lookup2[256] = { 0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
					0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
					0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
					0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
					0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
					0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
					0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
					0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
					0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
					0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
					0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
					0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
					0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
					0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
					0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
					0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5 };
const static int lookup3[256] = { 0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
					0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
					0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
					0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
					0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
					0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
					0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
					0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
					0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
					0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
					0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
					0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
					0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
					0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
					0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
					0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a };
const static int lookup9[256] = { 0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
					0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
					0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
					0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
					0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
					0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
					0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
					0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
					0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
					0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
					0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
					0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
					0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
					0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
					0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
					0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46 };
const static int lookup11[256] = { 0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
					0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
					0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
					0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
					0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
					0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
					0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
					0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
					0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
					0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
					0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
					0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
					0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
					0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
					0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
					0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3 };
const static int lookup13[256] = { 0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
					0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
					0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
					0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
					0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
					0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
					0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
					0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
					0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
					0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
					0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
					0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
					0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
					0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
					0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
					0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97 };
const static int lookup14[256] = { 0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
					0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
					0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
					0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
					0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
					0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
					0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
					0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
					0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
					0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
					0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
					0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
					0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
					0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
					0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
					0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d };
const static int rcon[10][4] = { {0x01,0x00,0x00,0x00},
						{0x02,0x00,0x00,0x00},
						{0x04,0x00,0x00,0x00},
						{0x08,0x00,0x00,0x00},
						{0x10,0x00,0x00,0x00},
						{0x20,0x00,0x00,0x00},
						{0x40,0x00,0x00,0x00},
						{0x80,0x00,0x00,0x00},
						{0x1B,0x00,0x00,0x00},
						{0x36,0x00,0x00,0x00} };
const static int BLOCKSIZE = 4;



void printBlock(int block[][4], std::string phase) {
	std::cout << "---------------" << phase << "---------------" << std::endl;
	for (int i = 0; i < BLOCKSIZE; i++) {
		for (int j = 0; j < BLOCKSIZE; j++) {
			std::cout << std::hex << block[j][i];
		}
	}
	std::cout << std::endl;
	for (int i = 0; i < BLOCKSIZE; i++) {
		for (int j = 0; j < BLOCKSIZE; j++) {
			std::cout << std::hex << block[j][i] << " ";
		}
	}
	std::cout << std::endl;
}

int AES::reverseSbox(int value) {
	int index = 0x00;
	for (int i = 0; i < 256; i++) {
		if (sbox_enc[i] == value) {
			index = i;
			break;
		}
	}
	return index;
}

int AES::dotProduct(int a, int b) {
	int baseNr = 0x00;
	switch (b) {

	case 0x01:
		baseNr = a;
		break;
	case 0x02:
		baseNr = lookup2[a];
		break;
	case 0x03:
		baseNr = lookup3[a];
		break;

	case 0x09:
		baseNr = lookup9[a];
		break;
	case 0x0b:
		baseNr = lookup11[a];
		break;
	case 0x0d:
		baseNr = lookup13[a];
		break;
	case 0x0e:
		baseNr = lookup14[a];
		break;
	}
	return baseNr;
}

void AES::setupKey(int key[]) {

	for (int i = 0; i < BLOCKSIZE; i++) {
		for (int j = 0; j < BLOCKSIZE; j++) {
			this->roundKey[0][j][i] = (int)key[i * 4 + j];
		}
	}
	for (int r = 1; r <= this->rounds; r++) {

		std::vector <int> rotWord = {};
		for (auto element : this->roundKey[r - 1]) { rotWord.push_back(element[3]); }
		std::rotate(rotWord.begin(), rotWord.begin() + 1, rotWord.end());

		std::vector <int> subByte = {};
		for (auto element : rotWord) { subByte.push_back(sbox_enc[element]); }

		for (int i = 0; i < BLOCKSIZE; i++) { //cols
			for (int j = 0; j < BLOCKSIZE; j++) { //rows
				if (i == 0) {
					this->roundKey[r][j][i] = (this->roundKey[r - 1][j][i] ^ subByte[j] ^ rcon[r - 1][j]);

				}
				else {
					this->roundKey[r][j][i] = (this->roundKey[r - 1][j][i] ^ this->roundKey[r][j][i - 1]);
				}
			}
		}
	}
}

int* AES::decryptBlock(int block[][4]) {

	//INITIAL ROUND
	for (int i = 0; i < BLOCKSIZE; i++) {
		for (int j = 0; j < BLOCKSIZE; j++) {
			block[j][i] = (block[j][i] ^ this->roundKey[rounds][j][i]);
		}
	}

	for (int r = this->rounds; r > 0; r--) {

		//SHIFT ROWS
		int temp_row[4];
		for (int i = 0; i < BLOCKSIZE; i++) {
			for (int j = 0; j < BLOCKSIZE; j++) {
				temp_row[j] = block[i][(j - i + BLOCKSIZE) % BLOCKSIZE];
			}
			for (int j = 0; j < BLOCKSIZE; j++) {
				block[i][j] = temp_row[j];
			}
		}

		//SUBBYTES
		for (int i = 0; i < BLOCKSIZE; i++) {
			for (int j = 0; j < BLOCKSIZE; j++) {
				block[j][i] = reverseSbox(block[j][i]);
			}
		}

		for (int i = 0; i < BLOCKSIZE; i++) {
			for (int j = 0; j < BLOCKSIZE; j++) {
				block[j][i] = (block[j][i] ^ this->roundKey[r - 1][j][i]);
			}
		}

		//MIX ROWS
		if (r > 1) {
			int temp_matrix[4][4];
			for (int i = 0; i < BLOCKSIZE; i++) {
				for (int j = 0; j < BLOCKSIZE; j++) {
					int a = dotProduct(block[0][i], decMatrix[j][0]);
					int b = dotProduct(block[1][i], decMatrix[j][1]);
					int c = dotProduct(block[2][i], decMatrix[j][2]);
					int d = dotProduct(block[3][i], decMatrix[j][3]);
					temp_matrix[j][i] = (a ^ b ^ c ^ d);
				}
			}

			for (int i = 0; i < BLOCKSIZE; i++) {
				for (int j = 0; j < BLOCKSIZE; j++) {
					block[i][j] = temp_matrix[i][j];
				}
			}
		}
	}
	return *block;
}

int* AES::encryptBlock(int block[][4]) {
	for (int i = 0; i < BLOCKSIZE; i++) {
		for (int j = 0; j < BLOCKSIZE; j++) {
			block[j][i] = (block[j][i] ^ this->roundKey[0][j][i]);
		}
	}

	for (int r = 1; r <= this->rounds; r++) {
		//SUBBYTES
		//IF IT FAILS HERE FOR SOME REASON, SOME VALUES IN BLOCK ARE INCORRECT
		for (int i = 0; i < BLOCKSIZE; i++) {
			for (int j = 0; j < BLOCKSIZE; j++) {
				block[j][i] = sbox_enc[block[j][i]];
			}
		}

		//SHIFT ROWS
		int temp_row[4];
		for (int i = 0; i < BLOCKSIZE; i++) {
			for (int j = 0; j < BLOCKSIZE; j++) {
				temp_row[j] = block[i][(j + i) % BLOCKSIZE];
			}
			for (int j = 0; j < BLOCKSIZE; j++) {
				block[i][j] = temp_row[j];
			}
		}

		//MIX ROWS
		if (r != this->rounds) {
			int temp_matrix[BLOCKSIZE][BLOCKSIZE];
			for (int i = 0; i < BLOCKSIZE; i++) {
				for (int j = 0; j < BLOCKSIZE; j++) {
					int a = dotProduct(block[0][i], encMatrix[j][0]);
					int b = dotProduct(block[1][i], encMatrix[j][1]);
					int c = dotProduct(block[2][i], encMatrix[j][2]);
					int d = dotProduct(block[3][i], encMatrix[j][3]);
					temp_matrix[j][i] = (a ^ b ^ c ^ d);
				}
			}

			for (int i = 0; i < BLOCKSIZE; i++) {
				for (int j = 0; j < BLOCKSIZE; j++) {
					block[i][j] = temp_matrix[i][j];
				}
			}
		}

		//ADD ROUND KEY
		for (int i = 0; i < BLOCKSIZE; i++) {
			for (int j = 0; j < BLOCKSIZE; j++) {
				block[j][i] = (block[j][i] ^ this->roundKey[r][j][i]);
			}
		}
	}
	return reinterpret_cast<int*>(block);
}

void AES::generateIV(int seed) {
	srand(seed);
	for (int i = 0; i < 16; i++) {
		IV[i % 4][i / 4] = rand() % (0xff + 1);
	}
}

void AES::encryptTextOFB(std::string inFile, std::string outFile) {
	time_t time(time_t * timer);
	generateIV(time(NULL));

	std::ifstream input;
	std::ofstream output;

	unsigned int message_block[4][4];

	unsigned int AEStransform[4][4];
	unsigned int cipher_block[4][4];

	int counter = 0;
	unsigned char byte = 0;

	input.open(inFile);
	output.open(outFile);

	// Write IV to output
	if (output.is_open()) {
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				output << std::hex << IV[j][i] << " ";
			}
		}
	}

	// Rest of the message handling
	if (output.is_open()){
		while (input.is_open()) {
			while (input >> std::noskipws >> byte) {
				if (counter < 16) {
					message_block[counter % 4][counter / 4] = (unsigned int) byte;
					counter++;
				}
				else {
					//ENCRYPT
					int* cypher = encryptBlock(IV);
					for (int i = 0; i < 4; i++) {
						for (int j = 0; j < 4; j++) {
							AEStransform[i][j] = *(cypher + (i * 4) + j);
							cipher_block[i][j] = AEStransform[i][j] ^ message_block[i][j];
						}
					}
					//OUTPUT
					for (int i = 0; i < 4; i++) {
						for (int j = 0; j < 4; j++) {
							output << std::hex << cipher_block[j][i] << " ";
						}
					}
					message_block[0][0] = (unsigned int) byte;
					counter = 1;
				}
			}
			// Not a multiple of block size (Append it or otherwise..)
			if (counter < 16) {
				for (int i = counter; i < 16; i++) {
					message_block[i % 4][i / 4] = 16 - counter;
				}
			}
			//ENCRYPT
			int* cypher = encryptBlock(IV);
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					AEStransform[i][j] = *(cypher + (i * 4) + j);
					cipher_block[i][j] = AEStransform[i][j] ^ message_block[i][j];
				}
			}
			//OUTPUT
			int bits_appended = (unsigned int) cipher_block[3][3];
			
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					output << std::hex << cipher_block[j][i] << " ";
				}
			}
			input.close();
		}
		output.close();
	}
}

void AES::decryptTextOFB(std::string inFile , std::string outFile) {

	unsigned int message_block[4][4];

	unsigned int AEStransform[4][4];
	unsigned int cipher_block[4][4];

	std::ifstream input;
	std::ofstream output;

	output.open(outFile);
	input.open(inFile);
	bool encrypt = false;

	int counter = 0;
	unsigned int byte = 0;

	// Read IV 
	if (input.is_open()) {
		for (int i = 0; i < 16; i++) {
			input >> std::hex >> byte;
	        IV[i % 4][i / 4] = (int)byte;
		}
	}

	if (output.is_open()) {
		while (input.is_open()) {
			while (input >> std::hex >> byte) {
				if (counter < 16) {
					message_block[counter % 4][counter / 4] = (int)byte;
					counter++;
				}
				else {
					//ENCRYPT
					int* cypher = encryptBlock(IV);
					for (int i = 0; i < 4; i++) {
						for (int j = 0; j < 4; j++) {
							AEStransform[i][j] = *(cypher + (i * 4) + j);
							cipher_block[i][j] = AEStransform[i][j] ^ message_block[i][j];
						}
					}
					//OUTPUT
					for (int i = 0; i < 4; i++) {
						for (int j = 0; j < 4; j++) {
							output << (unsigned char)cipher_block[j][i];
						}
					}
					message_block[0][0] = (unsigned int)byte;
					counter = 1;
				}
			}
			// Not a multiple of block size (Append it or otherwise..)
			if (counter < 16) {
				unsigned int diff = 16 - counter;
				for (int i = counter; i < 16; i++) {
					message_block[i % 4][i / 4] = diff;
				}
			}
			//ENCRYPT
			int* cypher = encryptBlock(IV);
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					AEStransform[i][j] = *(cypher + (i * 4) + j);
					cipher_block[i][j] = AEStransform[i][j] ^ message_block[i][j];
				}
			}
			//OUTPUT
			int bits_appended = cipher_block[3][3];

			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					if ((i * 4 + j) < (16 - bits_appended)) {
						output << (unsigned char)cipher_block[j][i];
					}

				}
			}
			input.close();
		}
		output.close();
	}
}

void AES::encryptTextCBC(std::string inFile, std::string outFile) {

	int initVecEnc[4][4] = { {0x00, 0x00, 0x00, 0x00},
							{0x00, 0x00, 0x00, 0x00},
							{0x00, 0x00, 0x00, 0x00},
							{0x00, 0x00, 0x00, 0x00} };

	std::ifstream input;
	std::ofstream output;

	int last_cipher[4][4];
	int prev_cipher[4][4];
	int cipher[4][4];
	int cipher_encrypted[4][4];
	int plain[4][4];

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			cipher_encrypted[i][j] = initVecEnc[j][i];
		}
	}
	int counter = 0;
	unsigned char byte = 0;

	bool firstBlock = true;

	input.open(inFile);
	output.open(outFile);

	if (output.is_open()) {
		while (input.is_open()) {
			while (input >> std::noskipws >> byte) {
				if (counter < 16) {
					if (firstBlock) {
						plain[counter % 4][counter / 4] = byte;
						cipher[counter % 4][counter / 4] = (byte ^ initVecEnc[counter % 4][counter / 4]);
					}
					else {
						plain[counter % 4][counter / 4] = byte;
						cipher[counter % 4][counter / 4] = (byte ^ cipher_encrypted[counter % 4][counter / 4]);
					}
					counter++;
				}
				else {
					printBlock(plain, "PLAIN");
					printBlock(cipher, "PLAIN + IV");
					// Save last block
					if (!firstBlock) {
						for (int i = 0; i < 4; i++) {
							for (int j = 0; j < 4; j++) {
								prev_cipher[j][i] = cipher_encrypted[j][i];
							}
						}
					}
					// Output previous block
					if (!firstBlock) {
						for (int i = 0; i < 4; i++) {
							for (int j = 0; j < 4; j++) {
								output << std::hex << cipher_encrypted[j][i] << " ";
							}
						}
					}
					// Encrypt the new block
					int* cypher = encryptBlock(cipher);
					for (int i = 0; i < 4; i++) {
						for (int j = 0; j < 4; j++) {
							cipher_encrypted[i][j] = *(cypher + (i * 4) + j);
						}
					}
					printBlock(cipher_encrypted, "PLAIN + IV ENCRYPTED");
					plain[0][0] = byte;
					cipher[0][0] = byte ^ cipher_encrypted[0][0];
					counter = 1;
					// The first time block is encrypted this will execute
					firstBlock = false;
				}
				//By here all blocks except for last and second to last should be encrypted
			}
			// Not a multiple of block size (Using ciphertext stealing)
			// Append 0's to last block
			if (counter < 16) {
				for (int i = counter; i < 16; i++) {
					plain[i % 4][i / 4] = 0x00;
				}
			}
			printBlock(plain, "PLAIN REAMINING");
			printBlock(cipher, "PLAIN + PREV CIPHER");
			//Saving the second to last block
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					last_cipher[j][i] = cipher_encrypted[j][i];
				}
			}

			// XOR with prev block 
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					cipher[i][j] = (plain[i][j] ^ cipher_encrypted[i][j]);
				}
			}

			//Encrypting last block + prev block XOR 
			int* cypher = encryptBlock(cipher);
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					cipher_encrypted[i][j] = *(cypher + (i * 4) + j);
				}
			}
			printBlock(cipher_encrypted, "SECOND TO LAST BLOCK");
			// Output previous block
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					output << std::hex << cipher_encrypted[j][i] << " ";
				}
			}

			//OUTPUT partial prev block
			for (int i = 0; i < counter; i++) {
				output << std::hex << last_cipher[i % 4][i / 4] << " ";
			}

			input.close();
		}
		output.close();
	}
}

void AES::decryptTextCBC(std::string inFile, std::string outFile) {

	// Predefined
	int initVecEnc[4][4] = { {0x00, 0x00, 0x00, 0x00},
							{0x00, 0x00, 0x00, 0x00},
							{0x00, 0x00, 0x00, 0x00},
							{0x00, 0x00, 0x00, 0x00} };

	std::ifstream input;
	std::ofstream output;

	// Dirty implementation for stealing ciphertext
	// Issue is that with the last blocks I need 2 
	// previous blocks to decrypt the last block
	// and I don't want to reuse variables
	int cipher_last[4][4];
	int cipher[4][4];
	int cipher_cpy[4][4];
	int decrypted_cipher[4][4];
	int prev_cipher[4][4];
	int last_plain[4][4];
	int stl_decrypted[4][4];
	int stl_plain[4][4];
	int plain[4][4];

	bool firstBlock = true;

	input.open(inFile);
	output.open(outFile);

	unsigned int byte = 0;

    // In order to avoid a spaghetti code implementation
    // all of the file contents are read into vector instead
    // of handling it through a stream in RT
	std::vector <unsigned int> cyphertext;
	while (input >> std::hex >> byte) {
		cyphertext.push_back(byte);
	}
	input.close();
	int full_blocks = cyphertext.size() / 16;
	bool all_full = cyphertext.size() % 16 == 0;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			prev_cipher[i][j] = initVecEnc[i][j];
		}
	}
	
	while (output.is_open()) {
		for (int i = 0; i < full_blocks; i++) {
			//READS THE BLOCK
			for (int j = 0; j < 16; j++) {
				cipher[j % 4][j / 4] = cyphertext[i * 16 + j];
				cipher_cpy[j % 4][j / 4] = cyphertext[i * 16 + j];
			}
			if (i + 1 == full_blocks) {
				//DECRYPT
				int* cypher = decryptBlock(cipher);
				for (int i = 0; i < 4; i++) {
					for (int j = 0; j < 4; j++) {
						decrypted_cipher[i][j] = *(cypher + (i * 4) + j);
					}
				}
				
				//WE HANDLE THE LAST BLOCK
				int missing_symbols = cyphertext.size() - full_blocks * 16;

				//READ IN LAST VALUES
				for (int z = full_blocks * 16; z < cyphertext.size(); z++) {
					cipher_last[z % 4][(z / 4) % 4] = cyphertext[z];
				}
				//ADD STL BLOCK MISSING VALUES
				for (int z = missing_symbols; z < 16; z++) {
					cipher_last[z % 4][z / 4] = decrypted_cipher[z % 4][z / 4];
				}
			
				//XOR LAST WITH STL
				for (int i = 0; i < 4; i++) {
					for (int j = 0; j < 4; j++) {
						last_plain[i][j] = cipher_last[i][j] ^ decrypted_cipher[i][j];
					}
				}

				//STL DECRYPTED
				cypher = decryptBlock(cipher_last);
				for (int i = 0; i < 4; i++) {
					for (int j = 0; j < 4; j++) {
						stl_decrypted[i][j] = *(cypher + (i * 4) + j);
					}
				}

				//STL PLAIN
				for (int i = 0; i < 4; i++) {
					for (int j = 0; j < 4; j++) {
						stl_plain[i][j] = stl_decrypted[i][j] ^ prev_cipher[i][j];
					}
				}

				//OUTPUT STL
				for (int i = 0; i < 4; i++) {
					for (int j = 0; j < 4; j++) {
						output << (char)stl_plain[j][i];
					}
				}

				//OUTPUT LAST (MINUS THE 0's = plaintext)
				for (int i = 0; i < 4; i++) {
					for (int j = 0; j < 4; j++) {
						if ((i * 4 + j) < missing_symbols) output << (char)last_plain[j][i];
					}
				}
			} else {
				//ELSE PROCESS SPECIAL
				int* cypher = decryptBlock(cipher);
				for (int i = 0; i < 4; i++) {
					for (int j = 0; j < 4; j++) {
						decrypted_cipher[i][j] = *(cypher + (i * 4) + j);
					}
				}
				for (int i = 0; i < 4; i++) {
					for (int j = 0; j < 4; j++) {
						plain[i][j] = prev_cipher[i][j] ^ decrypted_cipher[i][j];
					}
				}
				//SAVE CURR CIPHER AS LAST (NEEDED FOR NEXT BLOCK)
				for (int i = 0; i < 4; i++) {
					for (int j = 0; j < 4; j++) {
						prev_cipher[i][j] = cipher_cpy[i][j];
					}
				}
				//OUTPUT STL
				for (int i = 0; i < 4; i++) {
					for (int j = 0; j < 4; j++) {
						output << (char)plain[j][i];
					}
				}
			}
		}
		output.close();
	}
}


AES::AES(int key[], int rounds) {
	this->rounds = rounds;
	setupKey(key);
	
}
